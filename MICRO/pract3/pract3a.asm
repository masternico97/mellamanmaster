;*******************************************************************************
; PRACTICA 3 APARTADO A DE SISTEMAS BASADOS EN MICROPROCESADORES
; AUTORES: ALVARO SANCHEZ Y NICOLAS SERRANO
; PAREJA 10
;*******************************************************************************

DGROUP GROUP _DATA, _BSS				;; Se agrupan segmentos de datos en uno

_DATA SEGMENT WORD PUBLIC 'DATA' 		;; Segmento de datos DATA publico

  AUX DW ? ;LA EMPLEAREMOS PARA GUARDAR EN ELLA EL CONTENIDO DE ALGUN REGISTRO DE MANERA TEMPORAL
  DIEZ DW 10
  LIMIT DW 0

_DATA ENDS

_BSS SEGMENT WORD PUBLIC 'BSS'			;; Segmento de datos BSS publico

_BSS ENDS

; DEFINICION DEL SEGMENTO DE CODIGO

_TEXT SEGMENT BYTE PUBLIC  'CODE'
    ASSUME CS:_TEXT, DS:DGROUP, SS:DGROUP

PUBLIC _decodeBarCode
_decodeBarCode PROC FAR

  PUSH BP ;GUARDAMOS LOS REGISTROS QUE VAMOS A MODIFICAR

  MOV BP, SP

  PUSH SI
  PUSH ES
  PUSH AX
  PUSH BX
  PUSH CX
  PUSH DX
  PUSH DI

CONTROLDIGIT: ;OBTENEMOS EL DIGITO DE CONTROL
  LES SI, [BP+6] ;GUARDAMOS LA DIRECCION DE LA PRIMERA POSICION DEL ASCII
  MOV AL, ES:[SI+12]
  SUB AL, 48
  LES BX, [BP+22] ;GUARDAMOS LA DIRECCION DEL DIGITO DE CONTROL
  MOV ES:[BX], AL

PRODUCTCODE: ;CALCULAMOS EL CODIGO DE PRODUCTO
  LES SI, [BP+6]
  ADD SI, 7
  MOV [LIMIT], SI
  ADD SI, 4
  MOV DI, 1 ;UTILIZAREMOS ESTE REGISTRO PARA IR MULTIPLICANDO POR EL DIGITO
  MOV AH, 0
  MOV DX, 0
  MOV BX, 0 ;GUARDAMOS EL VALOR DEL CODIGO DE PRODUCTO
  MOV CX, 0
BUCLE1: ;BUCLE PARA CALCULAR EL NÚMERO DEL CODIGO DE PRODUCTO
  MOV AH, 0
	MOV AL, ES:[SI]
  SUB AL, 48
  MUL DI
  ADD BX, AX
  ADC CX, DX
  MOV AX, DI
  MUL [DIEZ]
  MOV DI, AX
  CMP SI, [LIMIT] ;COMPARAMOS SI HA LLEGADO AL LIMITE DEL BUCLE
  JE GUARDADOPC
  DEC SI
  JMP BUCLE1
GUARDADOPC:
  DEC SI
  MOV DX, BX
  LES BX, [BP+18] ;GUARDAMOS LA DIRECCION DEL CODIGO DE PRODUCTO
  MOV ES:[BX+2], CX
  MOV CX, DX
  MOV ES:[BX], CX

COMPANYCODE: ;CALCULAMOS EL CODIGO DE EMPRESA
  MOV [LIMIT], SI
  SUB [LIMIT], 3
  MOV DX, 1 ;UTILIZAREMOS ESTE REGISTRO PARA IR MULTIPLICANDO POR EL DIGITO
  MOV CL, 10 ;POR CADA CICLO AL PASAR UN DIGITO A LA IZQUIERDA HAREMOS DX*=CL
  MOV AH, 0
  MOV BX, 0 ;GUARDAMOS EL VALOR DEL CODIGO DE EMPRESA
BUCLE2: ;BUCLE PARA CALCULAR EL NÚMERO DEL CODIGO DE EMPRESA
  MOV AH, 0
  MOV AL, ES:[SI]
  SUB AL, 48
  MOV [AUX], DX
  MUL DX
  MOV DX, [AUX]
  ADD BX, AX
  MOV AX, DX
  MUL CL
  MOV DX, AX
  CMP SI, [LIMIT] ;COMPARAMOS SI HA LLEGADO AL LIMITE DEL BUCLE
  JE GUARDADOCC
  DEC SI
  JMP BUCLE2
GUARDADOCC:
  DEC SI
  MOV AX, BX
  LES BX, [BP+14] ;GUARDAMOS LA DIRECCION DEL CODIGO DE EMPRESA
  MOV ES:[BX], AX

COUNTRY_CODE: ;CALCULAMOS EL COUNTRY CODE
  MOV [LIMIT], SI
  SUB [LIMIT], 2
  MOV DX, 1 ;UTILIZAREMOS ESTE REGISTRO PARA IR MULTIPLICANDO POR EL DIGITO
  MOV CL, 10 ;POR CADA CICLO AL PASAR UN DIGITO A LA IZQUIERDA HAREMOS DX*=CL
  MOV AH, 0
  MOV BX, 0 ;GUARDAMOS EL VALOR DEL CODIGO DE PAIS
BUCLE3: ;BUCLE PARA CALCULAR EL NÚMERO DEL CODIGO DE PAIS
  MOV AH, 0
  MOV AL, ES:[SI]
  SUB AL, 48
  MOV [AUX], DX
  MUL DX
  MOV DX, [AUX]
  ADD BX, AX
  MOV AX, DX
  MUL CL
  MOV DX, AX
  CMP SI, [LIMIT] ;COMPARAMOS SI HA LLEGADO AL LIMITE DEL BUCLE
  JE GUARDADOCOUNTRYC
  DEC SI
  JMP BUCLE3
GUARDADOCOUNTRYC:
  MOV AX, BX
  LES BX, [BP+10] ;GUARDAMOS LA DIRECCION DEL CODIGO DE PAIS
  MOV ES:[BX], AX

  POP DI ;RECOGEMOS LOS REGISTROS QUE HEMOS MODIFICADO
  POP DX
  POP CX
  POP BX
  POP AX
  POP ES
  POP SI
  POP BP

  RET

_decodeBarCode ENDP


; COMIENZO DEL PROCEDIMIENTO (_computeControlDigit)
PUBLIC _computeControlDigit
_computeControlDigit PROC FAR

	PUSH BP	;GUARDAMOS EN LA PILA TODOS LOS REGISTROS QUE VAMOS A SOBRESCRIBIR
	PUSH BX
	PUSH CX
	PUSH DX
	PUSH SI
  PUSH ES

	MOV BP, SP
	LES BX, [BP+16]

	;OBTENEMOS LOS 12 PRIMEROS DIGITOS DE EL CODIGO EN ASCII PASANDOLOS A DECIMAL Y LOS GUARDAMOS EN LA PILA
	MOV CX, 0
LECTURA:
	MOV DX, ES:[BX]	;LOS CHAR SE EXTRAEN DE 2 EN 2
	SUB DH, 48	;CONVERSION NUMERO EN ASCII A HEX
	SUB DL, 48	;CONVERSION NUMERO EN ASCII A HEX
	PUSH DX	;GUARDAMOS LOS 2 NUMEROS CONVERTIDOS EN LA PILA
	ADD BX, 2
	INC CX
	CMP CX, 6
	JL LECTURA

PASO_1:
	MOV BX, 0	;BX ALMACENARA LA SUMA DE LOS DIGITOS IMPARES
	MOV CX, 0	;CX ALMACENARA LA SUMA DE LOS VALORES PARES * 3
	MOV SI, 0	;SI SE UTILIZA COMO CONTADOR DE BUCLE PUES TENEMOS CX UTILIZADO
BUCLE_PASO_1:	;SUMAMOS LOS VALORES DE LOS DIGITOS IMPARES Y SUMAMOS LOS VALORES DE LOS PARES * 3 (POR SEPARADO)
	POP DX
	ADD	BL, DL
	MOV AL, DH
	MOV AH, 3
	MUL AH
	ADD CX, AX
	INC SI
	CMP SI, 6
	JL BUCLE_PASO_1

PASO_2:
	ADD BX, CX

PASO_3y4:
	MOV AX, BX
	MOV DL, 10
	DIV DL	;CALCULAMOS EL PRIMER DIGITO DEL NUMERO OBTENIDO ANTERIORMENTE EXTAYENDO EL COCIENTE DE DIVIDIR ENTRE 10
	MOV AL, 10
	SUB AL, AH	;HACEMOS 10 - EL COCIENTE DE LA DIVISIÖN
	CMP AL, 10
	JE CERO
	MOV AH, 00h	;INTRODUCIMOS 00 EN LA PARTE ALTA DEL REGISTRO AX PUES LA SOLUCION SI NO ES POSITIVA
	JMP FIN
CERO:
	MOV AX, 0

FIN:
  POP ES
	POP SI	;SACAMOS DE LA PILA LOS REGISTROS QUE HABÍAMOS GUARDADO AL PRINCIPIO PARA QUE NO SE SOBRESCRIBIERAN
	POP	DX
	POP CX
	POP BX
	POP BP
	RET
_computeControlDigit ENDP

_TEXT ENDS
END
